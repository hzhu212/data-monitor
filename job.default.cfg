[DEFAULT]
period = day_and_above
is_active = true
retry_times = 0
retry_interval = 01:00:00

; 事先构建一些常用的时间变量，用户可以在自己的配置中引用
; 注意，由于 % 是 .cfg 文件的特殊符号，所以需要转义，使用 %% 来代表一个百分号
TODAY = {BASETIME | dt_format('%%Y%%m%%d')}
YESTERDAY = {BASETIME | dt_add(days=-1) | dt_format('%%Y%%m%%d')}
TODAY_ISO = {BASETIME | dt_format('%%Y-%%m-%%d')}
YESTERDAY_ISO = {BASETIME | dt_add(days=-1) | dt_format('%%Y-%%m-%%d')}



[__DOC__]
period =    ; 可选。监控周期，可取的值有：day_and_above, hour。默认为 day_and_above。
            ; 周期大于等于天的监控一律无需指定，可根据 due_time 所在的日期判断是否需要发起监控。

is_active = ; 可选。是否激活该监控，可取的值为：true, false。未激活的配置会被程序直接跳过。
            ; 默认为【未激活】状态（考虑到监控作业量巨大，需要大家手动确认激活）。

alarm_hi =  ; 必填。报警接收人百度Hi账号，以半角逗号分隔的列表。
alarm_email =; 必填。报警接收人百度邮箱或百度ID，以半角逗号分隔的列表。

due_time =  ; 必填。该条监控的触发时间，程序会保证当时钟超过该时刻后立即触发监控任务。
            ; 一个 ISO 格式的日期时间字符串，可通过 BASETIME 环境变量方便地生成（见下文）。
            ; 对于天级以上（周级、月级、年级）的监控，仅当 due_time 设定的日期刚好是当天时，才执行监控；
            ; 对于小时级监控，只需设定第一个小时的 due_time，后续监监控任务会以一小时为间隔自动追加。

db_conf =   ; 必填。数据库配置，需引用 database.cfg 中的 section name。如果有多个值，使用半角逗号分隔。
database =  ; 可选。数据库连接所使用的数据库名称。如果有多个值，使用半角逗号分隔。默认为 db_conf 中给出的值。

sql =       ; 必填。查询数据所调用的 SQL 语句，如果语句过长，可以写在一个 .sql 文件中，并在此填写其绝对路径。
            ; 如果有多个值，使用两个半角冒号（`::`）分隔（由于半角逗号是 SQL 语句的合法字符，因此无法用作分隔符；
            ; 另外，分号应该是最合适的分隔符，因为 .sql 文件中也使用分号分隔多个查询语句，但很遗憾分号正好是
            ; .cfg 格式的注释符号）。
            ; 多个 SQL 语句会返回多个查询结果集给校验表达式，需要配以对应数量的 db_conf, database 配置。

validator = ; 必填。校验表达式，一个合法的 Python 表达式，返回值应为 bool 类型。
            ; 如果返回 False 说明校验失败，将触发报警，否则不报警。
            ; 表达式中可以通过钩子变量 `result` 来调用 SQL 的返回结果。如果 SQL 的查询
            ; 结果是单个值，那么 `result` 就是该值；否则，`result` 是一个二层嵌套列表，
            ; 其中的每个子列表代表一行数据（遵循了 PEP249 的规范：https://www.python.org/dev/peps/pep-0249/#fetchmany）。
            ; 如果有多个 SQL，那么 result 也将包含对应的个数。
            ;
            ; 考虑到安全问题，校验表达式中并不能无限制地调用任意 Python 表达式，比如不应该调用
            ; `os.system('rm -rf /')`，因此我们对校验表达式的上下文环境进行了一定的限制，
            ; 使得用户只能调用 float, min, max, sum, map 等全局内置方法。但该上下文环境可以自由扩展，
            ; 用户可以自定义任意函数，只需要使用 `context.register_validator` 装饰器装饰，即可在校验表达式中调用。
            ; 为了方便使用，`validators.py` 文件中已经定义了一些常用的 validator 函数。
            ; 如果你的校验逻辑比较复杂，那么推荐你定义自己的 validator 函数，并在校验表达式中调用。

retry_times =    ; 如果数据校验结果失败，继续重试的次数。如果校验成功，不会触发重试。
retry_interval = ; 每次重试的间隔。


; 该部分补充说明配置相关的内部原理，你可以不必深入理解，当发生 ConfigError 时再排查这些内容。
; 为了最大化配置文件的灵活性，用户提供的配置文件需要经过一个“渲染”的步骤，然后才交给程序执行。
; 渲染步骤通过 jinja2 库来完成，渲染块标志符为 `{}`，下面你将会看到，通过灵活的渲染，
; 你几乎可以解决任何与日期、时间相关的问题。
; 渲染时程序会提供一定的上下文环境，你可以在渲染块中使用这些上下文：
; 1. 变量：
;    - `BASETIME`: `datetime.datetime` 类型，其值为监控程序调用当天的零时零分零秒。在程序启动时渲染。
;    - `DUETIME`: `datetime.datetime` 类型，当前作业开始执行的开始时间。执行 sql 前渲染，
;      因此只能在 sql 配置项中使用。
; 2. 函数（在 jinja2 中称为过滤器），其做用是通过管道符串接的方式灵活地操作变量，包括所有
;    使用 `context.register_filter` 装饰器装饰的函数。默认已实现的过滤器包括：
;    - dt_set(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]): 设置 datetime 绝对量
;    - dt_add(years, months, days[, hours[, minutes[, seconds[, microseconds]]]]): 设置 datetime 偏移量
;    - dt_format(fmt='%%Y-%%m-%%dT%%H:%%M:%%S.%%f'): 格式化 datetime，该示例为 ISO 8601 格式，即 YYYY-MM-DDTHH:MM:SS.mmmmmm
; 用法示例：
; - `{BASETIME | dt_add(months=-1) | dt_set(hour=8, minute=30)}`: 基准时间前一天的 08:30
; - `... where event_day = '{BASETIME | dt_format('%%Y-%%m-%%d')}'
;        AND hour = '{DUETIME | dt_add(hour=-1) | dt_format('%%H')}'`



[demo_simple_value]
; 单值监控
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse
sql =
    SELECT count(1)
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
validator = result > 40
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_simple_value_with_sql_in_file]
; 单值监控，sql 参数支持传入文件路径
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse
sql = ./sql/demo_simple_value_with_sql_in_file.sql
validator = result > 40
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_simple_diff]
; 单值 diff
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse, palo_muse_new
_sql =
    SELECT count(1)
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
sql = %(_sql)s :: %(_sql)s
validator = abs(result[0] - result[1]) < 1
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_two_table_diff]
; 两表 diff
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse, palo_muse_new
sql =
    SELECT product, partner, sum(expose) AS num
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
    GROUP BY product, partner
    ::
    SELECT product, partner, sum(expose) AS num
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
    GROUP BY product, partner
validator = diff(result, threshold=1)
alarm_hi = zhuhe02_02
alarm_email = zhuhe02
