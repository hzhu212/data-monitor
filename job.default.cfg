[DEFAULT]
period = day_and_above
is_active = true
retry_times = 0
retry_interval = 01:00:00

; 事先构建一些常用的时间变量，用户可以在自己的配置中引用
; 注意，由于 % 是 .cfg 文件的特殊符号，所以需要转义，使用 %% 来代表一个百分号
TODAY = {BASETIME | dt_format('%%Y%%m%%d')}
YESTERDAY = {BASETIME | dt_add(days=-1) | dt_format('%%Y%%m%%d')}
TODAY_ISO = {BASETIME | dt_format('%%Y-%%m-%%d')}
YESTERDAY_ISO = {BASETIME | dt_add(days=-1) | dt_format('%%Y-%%m-%%d')}



[__DOC__]
due_time =  ; 必填。该条监控的到期时间，当时钟超过该时刻后，当前监控任务将被触发。
            ; 一个 ISO 格式的日期时间字符串，可通过 BASETIME 环境变量生成（见下文）。
            ; 对于天级以上（周级、月级、年级）的监控，仅当 due_time 设定的日期刚好是当天时，才触发监控；
            ; 对于小时级监控，只需设定第一个小时的 due_time，后续监监控任务会以一小时为间隔自动生成。

db_conf =   ; 必填。数据库配置，引用 database.cfg 中的 section name。如果有多个值，使用半角逗号分隔。
database =  ; 可选。数据库连接所使用的数据库名称。如果有多个值，使用半角逗号分隔。默认为 database.cfg 中给出的值。

sql =       ; 必填。查询数据所调用的 SQL 语句，如果语句过长，可以写在一个 .sql 文件中，并在此填写文件路径。
            ; 如果有多个值，使用两个半角冒号（`::`）分隔（由于半角逗号是 SQL 语句的合法字符，因此无法用作分隔符；
            ; 另外，分号应该是最合适的分隔符，因为 .sql 文件中也使用分号分隔多个查询语句，但很遗憾分号正好是
            ; .cfg 格式的注释符号）。
            ; 多个 SQL 语句会返回多个查询结果集给校验表达式（见下文）。
            ; db_conf，database 以及 sql 如果包含多个值，那么值的数量必须相一致。

validator = ; 必填。校验表达式，一个合法的 Python 表达式，用于判定查询结果是否会触发报警。
            ; 返回值为一个布尔值，如果为 `False` 说明校验失败，将触发报警，程序会根据作业配置
            ; 自动生成报警原因。如果需要更细节的报警原因，可提供第二个返回值 `info` 作为定制信息。
            ; 校验表达式的核心基础在于它可以通过钩子变量 `result` 来引用 SQL 的返回结果：
            ; 如果 SQL 的查询结果是单个值（比如查询数据行数），那么 `result` 就是该值；
            ; 否则，`result` 是一个二维表格（嵌套列表），列表中的每一行代表查询结果的一行数据，
            ; 该规范详见 PEP249: https://www.python.org/dev/peps/pep-0249/#fetchmany）。
            ; 如果有多个 SQL，那么 result 会是一个数组，其中的每个元素分别代表一个查询结果，与 SQL 一一对应。
            ;
            ; 以下高阶内容，也是高扩展性的核心所在，普通用户可不必了解：
            ; 考虑到安全性问题，校验表达式中并不能无限制地调用任意 Python 表达式，比如不应该允许
            ; 用户调用 `os.system('rm -rf /')`。因此我们对校验表达式的上下文环境进行了一定的限制，
            ; 使得用户只能调用 float, min, max, sum, map 等安全的方法。
            ; 同时该上下文环境支持自由扩展，用户可以在其中使用任意自定义函数，只需要把想调用的函数
            ; 使用 `context.register_validator` 装饰器装饰即可。`data_monitor/user/validators.py`
            ; 文件中已经定义了一些常用的 validator 函数，可供参考。
            ; 如果你的校验逻辑比较复杂，那么推荐你定义自己的 validator 函数。

alarm_hi =  ; 必填。报警接收人的百度Hi账号，多个值以半角逗号分隔。
alarm_email=; 必填。报警接收人的百度邮箱或百度ID，多个值以半角逗号分隔。

period =    ; 可选。监控周期，可取的值有：day_and_above, hour，分别代表天级及以上监控、小时级监控。
            ; 默认为 day_and_above，一般监控作业无需指定该参数。

is_active = ; 可选。是否激活该监控，可取的值为：true, false。未激活的配置会跳过。可用于禁用某些监控作业。

retry_times =    ; 如果数据校验结果失败，继续重试的次数。如果校验成功，不会触发重试。默认为 0，即不重试。
retry_interval = ; 每次重试的间隔，默认为 01:00:00，即一小时后重试。


; 该部分补充说明配置相关的内部原理，你可以不必深入理解，当发生 ConfigError 时再排查这些内容。
; 为了最大化配置文件的灵活性，用户提供的配置文件需要经过一个“渲染”的步骤，然后才交给程序执行。
; 渲染步骤通过 jinja2 库来完成，渲染块标志符为 `{}`，下面你将会看到，通过灵活的渲染，
; 你几乎可以解决任何与日期、时间相关的问题。
; 渲染时程序会提供一定的上下文环境，你可以在渲染块中使用这些上下文：
; 1. 变量：
;    - `BASETIME`: `datetime.datetime` 类型，其值为监控程序调用当天的零时零分零秒。在程序启动时渲染。
;    - `DUETIME`: `datetime.datetime` 类型，当前作业开始执行的开始时间。执行 sql 前渲染，
;      因此只能在 sql 配置项中使用。
; 2. 函数（在 jinja2 中称为过滤器），其做用是通过管道符串接的方式灵活地操作变量，包括所有
;    使用 `context.register_filter` 装饰器装饰的函数。默认已实现的过滤器包括：
;    - dt_set(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]): 设置 datetime 绝对量
;    - dt_add(years, months, days[, hours[, minutes[, seconds[, microseconds]]]]): 设置 datetime 偏移量
;    - dt_format(fmt='%%Y-%%m-%%dT%%H:%%M:%%S.%%f'): 格式化 datetime，该示例为 ISO 8601 格式，即 YYYY-MM-DDTHH:MM:SS.mmmmmm
; 用法示例：
; - `{BASETIME | dt_add(months=-1) | dt_set(hour=8, minute=30)}`: 基准时间前一天的 08:30
; - `... where event_day = '{BASETIME | dt_format('%%Y-%%m-%%d')}'
;        AND hour = '{DUETIME | dt_add(hour=-1) | dt_format('%%H')}'`



[demo_simple_value]
; 单值监控
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse
sql =
    SELECT count(1)
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
validator = result > 40
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_simple_value_with_sql_in_file]
; 单值监控，sql 参数支持传入文件路径
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse
sql = ./sql/demo_simple_value_with_sql_in_file.sql
validator = result > 40
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_simple_diff]
; 单值 diff
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse, palo_muse_new
_sql =
    SELECT count(1)
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
sql = %(_sql)s :: %(_sql)s
validator = abs(result[0] - result[1]) < 1
alarm_hi = zhuhe02_02
alarm_email = zhuhe02


[demo_two_table_diff]
; 两表 diff
due_time = {BASETIME | dt_set(hour=9)}
db_conf = palo_muse, palo_muse_new
sql =
    SELECT product, partner, sum(click) AS num
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
    GROUP BY product, partner
    ::
    SELECT product, partner, sum(click) AS num
    FROM pmc_all_channel_advertising
    WHERE event_day = '%(YESTERDAY)s'
    GROUP BY product, partner
validator = diff(result[0], result[1], threshold=1)
alarm_hi = zhuhe02_02
alarm_email = zhuhe02
